*** maude demo hvl april 2021

fmod VAR is
    including QID .
    sort Var .
    subsort Qid < Var .
endfm

view Var from TRIV to VAR is
   sort Elt to Var .
endv

fmod EXPR is
    pr VAR .
    pr BOOL .
    pr INT .

    sort Val Expr .
    subsorts Bool Int < Val .
    subsorts Var Val < Expr .
    
    op _+_ : Expr Expr -> Expr [ditto] .
    op _*_ : Expr Expr -> Expr [ditto] .
    op _=:=_ : Expr Expr -> Expr [prec 25] . --- equality
    op _<_ : Expr Expr -> Expr [ditto] .
    op not_ : Expr -> Expr [ditto] .
    op _and_ : Expr Expr -> Expr [ditto] .
    op _or_ : Expr Expr -> Expr [ditto] .
    
endfm

view Val from TRIV to EXPR is
    sort Elt to Val .
endv

fmod STATE is
    pr VAR .
    pr EXPR .
    pr MAP{Var, Val} .

    sort Substitution .
    subsort Map{Var, Val} < Substitution .
endfm

fmod EVAL is
    pr EXPR .
    pr STATE .

    var M : Substitution .
    var N : Int .
    var B : Bool .
    var V : Var .
    vars E1 E2 : Expr .
    
    op eval : Substitution Expr -> Val .
    *** Observe we are assuming that expressions are type-correct,
    *** otherwise reduction will get stuck.
    eq eval(M, N) = N .
    eq eval(M, B) = B .
    eq eval(M, V) = M[V] .

    eq eval(M, E1 + E2) = eval(M, E1) + eval(M, E2) .
    eq eval(M, E1 * E2) = eval(M, E1) * eval(M, E2) .

    eq eval(M, E1 =:= E2) = eval(M, E1) == eval(M, E2) .
    eq eval(M, E1 < E2) = eval(M, E1) < eval(M, E2) .
    eq eval(M, E1 and E2) = eval(M, E1) and eval(M, E2) .
    eq eval(M, E1 or E2) = eval(M, E1) or eval(M, E2) .
    eq eval(M, not(E1)) = not(eval(M, E1)) .
	    
endfm

*** red eval(empty, 5).
*** red eval('x |-> 5, 'x + 2) .
*** red eval(('x |-> 5, 'y |-> 7), 'y * ('x + 2)) .
*** red eval(('x |-> 5, 'y |-> 7), 'y < ('x + 2)) .
*** red eval(('x |-> 5, 'y |-> 7), 'y < ('x + 3)) .
*** red eval(('x |-> true, 'y |-> false), 'y or 'x) .
*** red eval(('x |-> true, 'y |-> false), 'y or true) .
*** red eval(('x |-> true, 'y |-> false), false or (true and 'x)) .
*** red eval(('x |-> true, 'y |-> false), true and 'x) .

fmod STM is
    pr EVAL .
    
    sort Update Spawn Stm .
    subsorts Update Spawn < Stm .
    
    op _:=_ : Var Expr -> Update [ctor] .
    op spawn : GStm -> Spawn [ctor] .
    
    sort Skip Sequence If IfElse GStm .
    subsorts Skip Sequence If IfElse < GStm .
    
    op skip : -> Skip [ctor] .
    op seq : GStm GStm -> Sequence [ctor] .
    op if : Expr Stm -> If [ctor] .
    op ifElse : Stm Expr Stm -> IfElse [ctor] .
endfm

*** fmod GSTM is
***    pr STMBase .    
*** endfm

*** Not 100% sure if needed but changes the console output
view GStm from TRIV to STM is
    sort Elt to GStm .
endv

fmod THREADS is
    pr STM .
    pr SET{GStm} .
    sort Threads .
    subsort Set{GStm} < Threads .   
endfm

fmod RUNTIME is
    pr THREADS .
    pr EVAL .
    sort Runtime .
    op run : Substitution Threads -> Runtime [ctor] .
    
endfm

mod SEMANTICS is
	pr RUNTIME .
    var M : Substitution .
    vars G1 G2 : GStm .
    vars S1 S2 : Stm .
    var E1, E2 : Expr .
    var S : Var .
    var N : Threads .
    
    rl [delSkip] : run(M, (skip, N)) => run(M, N) .
    crl [if] : run(M, (if(E1, S1), N)) => execute(S1, M, N) if eval(M, E1) .
    
    crl [ifElse] : run(M, (ifElse(S1, E1, S2), N)) => execute(S1, M, N) if eval(M, E1).
    crl [ifElse] : run(M, (ifElse(S1, E1, S2), N)) => execute(S2, M, N) if true =/= eval(M, E1) .
    
    rl [seqSkip] : run(M, (seq(skip, G2), N)) => run(M, insert(G2, N)).
    crl [seqIf] : run(M, (seq(if(E1, S1), G2), N)) => execute(S1, M, insert(G2, N)) if eval(M, E1).
    crl [seqIfElse] : run(M, (seq(ifElse(S1, E1, S2), G2), N)) => execute(S1, M, insert(G2, N)) if eval(M, E1).
    crl [seqIfElse] : run(M, (seq(ifElse(S1, E1, S2), G2), N)) => execute(S2, M, insert(G2, N)) if true =/= eval(M, E1).
        
    op execute : Stm Substitution Threads -> Runtime .
    eq execute (spawn(G1), M, N) = run(M, insert(G1, N)) .
    eq execute (S := E1, M, N) = run(update(M, S := E1), N) .
    
    op update : Substitution Update -> Substitution .
    eq update(M, S := E1) = insert(S, eval(M,E1), M) .
endm
*** Skip:
*** rew run(('x |-> true), (skip, empty)) .
*** rew [10] run(('x |-> true), (seq(skip, skip), empty)) .
*** if:
*** rew [10] run(('x |-> true), (if('x, 'x := false), empty)) .
*** rew [10] run(('x |-> true, 'y |-> true), (if('x, 'x := false), if('y, 'y := false), empty)) .
*** rew [10] run(('x |-> false), (if('x, 'x := true), empty)) .
*** rew [10] run(('x |-> true), (if('x, spawn(skip)), empty)) .
*** rew [10] run(('x |-> true), (if('x, spawn(if('x, spawn(skip)))), empty)) .
*** ifElse: if
*** rew [10] run(('x |-> true), (ifElse('y := true, 'x, 'y := false), empty)) .
*** rew [10] run(('x |-> true), (ifElse(spawn(skip), 'x, 'y := false), empty)) .
*** rew [10] run(('x |-> true), (ifElse(spawn(if('x, 'y := true)), 'x, spawn(if('x, spawn(skip)))), empty)) .
*** ifElse: else
*** rew [10] run(('x |-> false), (ifElse('y := true, 'x, 'y := false), empty)) .
*** rew [10] run(('x |-> false), (ifElse('y := true, 'x, spawn(skip)), empty)) .
*** seq:
*** rew [10] run(('x |-> false), (seq(skip, skip), empty)) .
*** rew [10] run(('x |-> true), (seq(if('x, 'x := false), skip), empty)) .
*** rew [10] run(('x |-> true), (seq(ifElse('y := true, 'x, 'y := false), skip), empty)) .
*** rew [10] run(('x |-> false), (seq(ifElse('y := true, 'x, 'y := false), skip), empty)) .























package PropositionalLogic.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_And;
  private ConceptPresentation props_AtomicFormula;
  private ConceptPresentation props_BinaryFormula;
  private ConceptPresentation props_Formula;
  private ConceptPresentation props_Implication;
  private ConceptPresentation props_Not;
  private ConceptPresentation props_Or;
  private ConceptPresentation props_TruthTable;
  private ConceptPresentation props_TruthTableList;
  private ConceptPresentation props_TwoSidedImplication;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.And:
        if (props_And == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("And");
          props_And = cpb.create();
        }
        return props_And;
      case LanguageConceptSwitch.AtomicFormula:
        if (props_AtomicFormula == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.presentationByName();
          props_AtomicFormula = cpb.create();
        }
        return props_AtomicFormula;
      case LanguageConceptSwitch.BinaryFormula:
        if (props_BinaryFormula == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_BinaryFormula = cpb.create();
        }
        return props_BinaryFormula;
      case LanguageConceptSwitch.Formula:
        if (props_Formula == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_Formula = cpb.create();
        }
        return props_Formula;
      case LanguageConceptSwitch.Implication:
        if (props_Implication == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("Implication");
          props_Implication = cpb.create();
        }
        return props_Implication;
      case LanguageConceptSwitch.Not:
        if (props_Not == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("Not");
          props_Not = cpb.create();
        }
        return props_Not;
      case LanguageConceptSwitch.Or:
        if (props_Or == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("Or");
          props_Or = cpb.create();
        }
        return props_Or;
      case LanguageConceptSwitch.TruthTable:
        if (props_TruthTable == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.presentationByName();
          props_TruthTable = cpb.create();
        }
        return props_TruthTable;
      case LanguageConceptSwitch.TruthTableList:
        if (props_TruthTableList == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("TruthTableList");
          props_TruthTableList = cpb.create();
        }
        return props_TruthTableList;
      case LanguageConceptSwitch.TwoSidedImplication:
        if (props_TwoSidedImplication == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("TwoSidedImplication");
          props_TwoSidedImplication = cpb.create();
        }
        return props_TwoSidedImplication;
    }
    return null;
  }
}
